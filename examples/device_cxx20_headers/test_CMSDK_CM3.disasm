
test_CMSDK_CM3:     file format elf32-littlearm


Disassembly of section .text:

000100d8 <main>:
    public :

    using datatype_t = typename R::datatype;

    void write(datatype_t value) {
        *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset) = value;
   100d8:	2301      	movs	r3, #1
   100da:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
#include "SPI_mmio_dev.hpp"
#include "WDT_mmio_dev.hpp"
#include "FPGAIO_mmio_dev.hpp"
#include "SCC_mmio_dev.hpp"

int main(void) {
   100de:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   100e2:	f04f 2a40 	mov.w	sl, #1073758208	@ 0x40004000
   100e6:	6003      	str	r3, [r0, #0]
    }
    void clr(datatype_t value) {
        *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset) &= ~value;
    }
    datatype_t read(void) {
        return *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset);
   100e8:	6804      	ldr	r4, [r0, #0]
           // Write to single field.
           *reinterpret_cast<volatile r_datatype_t*>(BASE_ADDR + R::offset) =
               ((r_datatype_t)value << F::bit_offset) & F::bit_mask;
        } else {
            // Read write modify
            r_datatype_t reg_value = *reinterpret_cast<volatile r_datatype_t*>(BASE_ADDR + R::offset);
   100ea:	6804      	ldr	r4, [r0, #0]
        *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset) = value;
   100ec:	4923      	ldr	r1, [pc, #140]	@ (1017c <main+0xa4>)
            reg_value = (((r_datatype_t)value << F::bit_offset) & F::bit_mask) | (reg_value & ~F::bit_mask);
   100ee:	431c      	orrs	r4, r3
            *reinterpret_cast<volatile r_datatype_t*>(BASE_ADDR + R::offset) = reg_value;
   100f0:	6004      	str	r4, [r0, #0]
     */
    f_datatype_t read(void) {
        if constexpr ((R::bit_width == F::bit_width) && (F::bit_offset == 0)) {
            return (f_datatype_t) *reinterpret_cast<volatile r_datatype_t*>(BASE_ADDR + R::offset);
        } else {
            return (f_datatype_t) ((*reinterpret_cast<volatile r_datatype_t*>(BASE_ADDR + R::offset)) & F::bit_mask)  >> F::bit_offset;
   100f2:	6800      	ldr	r0, [r0, #0]
        *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset) = value;
   100f4:	600b      	str	r3, [r1, #0]
        return *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset);
   100f6:	6808      	ldr	r0, [r1, #0]
            r_datatype_t reg_value = *reinterpret_cast<volatile r_datatype_t*>(BASE_ADDR + R::offset);
   100f8:	6808      	ldr	r0, [r1, #0]
        *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset) = value;
   100fa:	f8df b084 	ldr.w	fp, [pc, #132]	@ 10180 <main+0xa8>
            reg_value = (((r_datatype_t)value << F::bit_offset) & F::bit_mask) | (reg_value & ~F::bit_mask);
   100fe:	4318      	orrs	r0, r3
            *reinterpret_cast<volatile r_datatype_t*>(BASE_ADDR + R::offset) = reg_value;
   10100:	6008      	str	r0, [r1, #0]
            return (f_datatype_t) ((*reinterpret_cast<volatile r_datatype_t*>(BASE_ADDR + R::offset)) & F::bit_mask)  >> F::bit_offset;
   10102:	6809      	ldr	r1, [r1, #0]
        *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset) = value;
   10104:	f8df 907c 	ldr.w	r9, [pc, #124]	@ 10184 <main+0xac>
   10108:	f8cb 3000 	str.w	r3, [fp]
        return *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset);
   1010c:	f8db 1000 	ldr.w	r1, [fp]
        *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset) = value;
   10110:	f8df 8074 	ldr.w	r8, [pc, #116]	@ 10188 <main+0xb0>
   10114:	f8ca 3000 	str.w	r3, [sl]
        return *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset);
   10118:	f8da 1000 	ldr.w	r1, [sl]
        *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset) = value;
   1011c:	f8df e06c 	ldr.w	lr, [pc, #108]	@ 1018c <main+0xb4>
   10120:	f8c9 3000 	str.w	r3, [r9]
        return *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset);
   10124:	f8d9 1000 	ldr.w	r1, [r9]
        *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset) = value;
   10128:	f8df c064 	ldr.w	ip, [pc, #100]	@ 10190 <main+0xb8>
   1012c:	f8c8 3000 	str.w	r3, [r8]
        return *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset);
   10130:	f8d8 1000 	ldr.w	r1, [r8]
        *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset) = value;
   10134:	4f17      	ldr	r7, [pc, #92]	@ (10194 <main+0xbc>)
   10136:	f8ce 3000 	str.w	r3, [lr]
        return *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset);
   1013a:	f8de 1000 	ldr.w	r1, [lr]
        *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset) = value;
   1013e:	4e16      	ldr	r6, [pc, #88]	@ (10198 <main+0xc0>)
   10140:	f8cc 3000 	str.w	r3, [ip]
        return *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset);
   10144:	f8dc 1000 	ldr.w	r1, [ip]
        *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset) = value;
   10148:	4d14      	ldr	r5, [pc, #80]	@ (1019c <main+0xc4>)
   1014a:	603b      	str	r3, [r7, #0]
        return *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset);
   1014c:	6839      	ldr	r1, [r7, #0]
        *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset) = value;
   1014e:	6033      	str	r3, [r6, #0]
        return *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset);
   10150:	6831      	ldr	r1, [r6, #0]
        *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset) = value;
   10152:	602b      	str	r3, [r5, #0]
        return *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset);
   10154:	6829      	ldr	r1, [r5, #0]
        *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset) = value;
   10156:	4912      	ldr	r1, [pc, #72]	@ (101a0 <main+0xc8>)
   10158:	4a12      	ldr	r2, [pc, #72]	@ (101a4 <main+0xcc>)
   1015a:	600b      	str	r3, [r1, #0]
        return *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset);
   1015c:	6809      	ldr	r1, [r1, #0]
        *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset) = value;
   1015e:	6013      	str	r3, [r2, #0]
        return *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset);
   10160:	6811      	ldr	r1, [r2, #0]
            r_datatype_t reg_value = *reinterpret_cast<volatile r_datatype_t*>(BASE_ADDR + R::offset);
   10162:	6810      	ldr	r0, [r2, #0]
        *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset) = value;
   10164:	4910      	ldr	r1, [pc, #64]	@ (101a8 <main+0xd0>)
            reg_value = (((r_datatype_t)value << F::bit_offset) & F::bit_mask) | (reg_value & ~F::bit_mask);
   10166:	4318      	orrs	r0, r3
            *reinterpret_cast<volatile r_datatype_t*>(BASE_ADDR + R::offset) = reg_value;
   10168:	6010      	str	r0, [r2, #0]
            return (f_datatype_t) ((*reinterpret_cast<volatile r_datatype_t*>(BASE_ADDR + R::offset)) & F::bit_mask)  >> F::bit_offset;
   1016a:	6812      	ldr	r2, [r2, #0]
        *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset) = value;
   1016c:	600b      	str	r3, [r1, #0]
        return *reinterpret_cast<volatile datatype_t*>(BASE_ADDR + R::offset);
   1016e:	680a      	ldr	r2, [r1, #0]
           *reinterpret_cast<volatile r_datatype_t*>(BASE_ADDR + R::offset) =
   10170:	600b      	str	r3, [r1, #0]
    auto SCC_CFG_REG0_v = SCC_i.CFG_REG0.read();
    // Field : REMAP
    SCC_i.CFG_REG0.REMAP.write(1);
    auto SCC_CFG_REG0_REMAP_v = SCC_i.CFG_REG0.REMAP.read();

   10172:	2000      	movs	r0, #0
            return (f_datatype_t) ((*reinterpret_cast<volatile r_datatype_t*>(BASE_ADDR + R::offset)) & F::bit_mask)  >> F::bit_offset;
   10174:	680b      	ldr	r3, [r1, #0]
   10176:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1017a:	bf00      	nop
   1017c:	40001000 	.word	0x40001000
   10180:	40002000 	.word	0x40002000
   10184:	40005000 	.word	0x40005000
   10188:	40006000 	.word	0x40006000
   1018c:	40007000 	.word	0x40007000
   10190:	40009000 	.word	0x40009000
   10194:	40010000 	.word	0x40010000
   10198:	40011000 	.word	0x40011000
   1019c:	40027000 	.word	0x40027000
   101a0:	40008000 	.word	0x40008000
   101a4:	40028000 	.word	0x40028000
   101a8:	4002f000 	.word	0x4002f000
